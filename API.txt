===============================================================================
  DIES IRAE MOD - MODDING API REFERENCE
  For The Binding of Isaac: Repentance / Repentogon
===============================================================================

  To access the mod reference in your own mod:

      local diesIrae = _G["DiesIraeMod"]
      if not diesIrae then return end  -- Dies Irae not loaded, bail safely


===============================================================================
  1. SACRIFICE TABLE API
     File: scripts/npcs/sacrifice_table.lua
===============================================================================

  The Sacrifice Table accepts player familiars as sacrifices. For it to
  correctly identify and remove a familiar from your mod, it needs to know
  which collectible owns it.

  METHOD 1 — Repentogon (Recommended)
  ------------------------------------
  If your familiar is spawned by a collectible and has a valid ItemConfig,
  no registration needed. The table detects it automatically via
  familiar:GetItemConfig().

  METHOD 2 — Manual Registration (Legacy / Fallback)
  ---------------------------------------------------
  Use this if your familiar has no valid ItemConfig.

  Parameters:
    familiarName    (string, required) - Exact entity name from entities2.xml
    collectibleName (string, required) - Exact item name from items.xml
    spritePath      (string, optional) - Ignored; item icon is always used

  Common mistakes:
    - Name doesn't match entities2.xml or items.xml exactly (case-sensitive)
    - Familiar has no parent collectible at all
    - Using Method 2 for a Repentogon familiar (use Method 1 instead)

  On failure: error buzz, nothing consumed. Check console for "[Dies Irae API]".

  -----------------------------------------------------------------------
  EXAMPLE — Sacrifice Table Registration
  -----------------------------------------------------------------------

      -- In your mod's main.lua, after Dies Irae has loaded:

      local diesIrae = _G["DiesIraeMod"]

      if diesIrae and diesIrae.RegisterModdedFamiliar then

          -- Register a single familiar
          diesIrae:RegisterModdedFamiliar(
              "My Cool Familiar",   -- Must match entities2.xml exactly
              "My Cool Item"        -- Must match items.xml exactly
          )

          -- Register multiple familiars from the same mod
          diesIrae:RegisterModdedFamiliar("Shadow Clone",   "Shadow Clone")
          diesIrae:RegisterModdedFamiliar("Golden Spider",  "Golden Web")
          diesIrae:RegisterModdedFamiliar("Haunted Lantern", "Old Lantern")

      end


===============================================================================
  2. ELIJAH BEGGAR API
     File: scripts/npcs/elijah/elijah_utils_beggar.lua
===============================================================================

  Elijah's beggars drain his Wills instead of coins. There are two ways to
  make a compatible beggar depending on how complex it is.

  -----------------------------------------------------------------------
  TIER 1 — RegisterElijahBeggar (Standard beggars)
  -----------------------------------------------------------------------
  Use this for beggars that follow the standard animation flow:
    Idle -> PayPrize / PayNothing -> Prize -> Teleport

  The API wires up all callbacks automatically and adds poof-on-error safety.

  Config fields:
    baseChance          - Base reward chance per use (0.0 to 1.0)
    multPerUse          - Chance increase per use
    hasSecondary        - Whether a secondary event pool exists
    secondaryBaseChance - Base secondary reward chance
    secondaryMultPerUse - Secondary chance increase per use
    restockAffected     - Whether Restock item penalises this beggar

  Event table format:
    { weight, function(beggarEntity, player) ... return shouldTeleport end }
    Weight is relative: { {1, funcA}, {10, funcB} } makes funcB 10x more likely.
    Return true = beggar teleports away after reward. false = beggar stays.

  On registration error: prints to console, aborts.
  On runtime error: prints to console, poofs the beggar.

  -----------------------------------------------------------------------
  EXAMPLE — Tier 1: Standard beggar with item and trinket rewards
  -----------------------------------------------------------------------

      -- In your mod's main.lua, after Dies Irae has loaded:

      local diesIrae = _G["DiesIraeMod"]
      if not diesIrae then return end

      local beggarUtils = include("scripts.npcs.elijah.elijah_utils_beggar")

      if diesIrae.RegisterElijahBeggar then
          diesIrae:RegisterElijahBeggar({

              variant = MyMod.Entities.MY_BEGGAR_VARIANT,  -- your slot variant

              config = {
                  baseChance          = 0.30,   -- 30% base chance
                  multPerUse          = 0.08,   -- +8% per use
                  hasSecondary        = true,   -- enable secondary reward pool
                  secondaryBaseChance = 0.15,   -- 15% secondary base chance
                  secondaryMultPerUse = 0.05,   -- +5% per use
                  restockAffected     = false,  -- Restock does not affect this beggar
              },

              -- Primary reward pool: weighted list of possible rewards
              primaryEvents = {
                  -- 10x weight: give a treasure room item, beggar teleports away
                  { 10, function(beggarEntity, player)
                      beggarUtils.SpawnItemFromPool(beggarEntity, ItemPoolType.POOL_TREASURE)
                      return true
                  end },

                  -- 3x weight: give a devil room item, beggar teleports away
                  { 3, function(beggarEntity, player)
                      beggarUtils.SpawnItemFromPool(beggarEntity, ItemPoolType.POOL_DEVIL)
                      return true
                  end },

                  -- 1x weight: give a specific item, beggar stays
                  { 1, function(beggarEntity, player)
                      beggarUtils.SpawnItem(beggarEntity, CollectibleType.COLLECTIBLE_PACT)
                      return false
                  end },
              },

              -- Secondary reward pool: lower-value consolation rewards
              secondaryEvents = {
                  -- Give a random trinket, beggar stays
                  { 5, function(beggarEntity, player)
                      beggarUtils.SpawnTrinket(beggarEntity, TrinketType.TRINKET_SWALLOWED_PENNY)
                      return false
                  end },

                  -- Give a bomb, beggar stays
                  { 3, function(beggarEntity, player)
                      beggarUtils.SpawnPickup(beggarEntity, PickupVariant.PICKUP_BOMB, 0)
                      return false
                  end },
              },
          })
      end


  -----------------------------------------------------------------------
  TIER 2 — Custom state machine (Complex beggars)
  -----------------------------------------------------------------------
  Use this for beggars with unique animations, multiple payment stages,
  or any logic that doesn't fit the standard Idle/Prize/Teleport flow.

  Write your own callbacks entirely. Call DrainElijahsWill for Will integration.

  DrainElijahsWill(player, rng)
    Checks Will count, reduces a random stat, updates cache.
    Returns true if a Will was consumed, false if not enough Will.

  -----------------------------------------------------------------------
  EXAMPLE — Tier 2: Custom beggar with 3 payment stages
  -----------------------------------------------------------------------

      -- Paste this into its own file, e.g. my_custom_beggar.lua
      -- Requires the standard animation set PLUS: PayPrize2, PayPrize3,
      -- Prize2, Prize3, Idle2, Idle3 in your anm2.

      local mod = DiesIraeMod
      local game = Game()

      local beggarUtils = include("scripts.npcs.elijah.elijah_utils_beggar")

      local MY_BEGGAR   = MyMod.Entities.MY_CUSTOM_BEGGAR_VARIANT
      local MAX_PAYS    = 3
      local WILL_COST   = 2  -- Drains 2 Wills per payment

      local State = { IDLE = 0, PAY = 1, PRIZE = 2, TELEPORT = 3 }

      -- COLLISION
      mod:AddCallback(ModCallbacks.MC_POST_SLOT_COLLISION, function(_, beggar, collider)
          if beggar.Variant ~= MY_BEGGAR then return end

          local player = collider:ToPlayer()
          if not player then return end
          if player:GetPlayerType() ~= mod.Players.Elijah then return end

          local data   = beggar:GetData()
          local sprite = beggar:GetSprite()

          if not data.Initialized then return end
          if data.State ~= State.IDLE then return end
          if data.Pays >= MAX_PAYS then return end

          -- Drain WILL_COST Wills
          local drained = 0
          for i = 1, WILL_COST do
              if beggarUtils.DrainElijahsWill(player, beggar:GetDropRNG()) then
                  drained = drained + 1
              else
                  break
              end
          end

          if drained < WILL_COST then
              -- Not enough Will — reject
              game:GetHUD():ShowItemText("Need " .. WILL_COST .. " Will!", "", false)
              return
          end

          data.Pays  = data.Pays + 1
          data.State = State.PAY

          -- Play the matching pay animation for this stage
          if data.Pays == 1 then sprite:Play("PayPrize",  true) end
          if data.Pays == 2 then sprite:Play("PayPrize2", true) end
          if data.Pays == 3 then sprite:Play("PayPrize3", true) end

      end, MY_BEGGAR)

      -- UPDATE
      mod:AddCallback(ModCallbacks.MC_POST_SLOT_UPDATE, function(_, beggar)
          if beggar.Variant ~= MY_BEGGAR then return end

          local data   = beggar:GetData()
          local sprite = beggar:GetSprite()
          local rng    = beggar:GetDropRNG()

          -- Initialise on first update
          if not data.Initialized then
              data.Initialized = true
              data.Pays  = 0
              data.State = State.IDLE
              sprite:Play("Idle", true)
              return
          end

          beggar.Velocity = Vector.Zero

          -- PAY -> PRIZE
          if data.State == State.PAY and sprite:IsFinished() then
              data.State = State.PRIZE
              if data.Pays == 1 then sprite:Play("Prize",  true) end
              if data.Pays == 2 then sprite:Play("Prize2", true) end
              if data.Pays == 3 then sprite:Play("Prize3", true) end
          end

          -- PRIZE -> spawn reward -> IDLE or TELEPORT
          if data.State == State.PRIZE and sprite:IsFinished() then

              -- Spawn your reward here — replace with whatever you want
              beggarUtils.SpawnItemFromPool(beggar, ItemPoolType.POOL_TREASURE)

              if data.Pays < MAX_PAYS then
                  data.State = State.IDLE
                  if data.Pays == 1 then sprite:Play("Idle2", true) end
                  if data.Pays == 2 then sprite:Play("Idle3", true) end
              else
                  data.State = State.TELEPORT
                  sprite:Play("Teleport", true)
              end
          end

          -- TELEPORT -> remove
          if data.State == State.TELEPORT and sprite:IsFinished("Teleport") then
              beggar:Remove()
          end

      end, MY_BEGGAR)

      -- EXPLOSION
      mod:AddCallback(ModCallbacks.MC_PRE_SLOT_CREATE_EXPLOSION_DROPS, function(_, beggar)
          if beggar.Variant ~= MY_BEGGAR then return end
          beggarUtils.DoBeggarExplosion(beggar)
          return false
      end, MY_BEGGAR)


  -----------------------------------------------------------------------
  SPAWN HELPERS (available to both tiers)
  -----------------------------------------------------------------------
  Include the utils file to access these:

      local beggarUtils = include("scripts.npcs.elijah.elijah_utils_beggar")

    SpawnItemFromPool(beggarEntity, itemPool)     - Item from a pool (respects blacklist)
    SpawnItem(beggarEntity, collectibleType)      - Specific collectible
    SpawnPickup(beggarEntity, variant, subtype)   - Any pickup (subtype optional)
    SpawnTrinket(beggarEntity, trinketType)       - Trinket
    SpawnFamiliar(beggarEntity, familiarVariant)  - Familiar


===============================================================================
  CONTACT
===============================================================================

  Questions or compatibility requests: Dies Irae Discrod server.

===============================================================================